## JVM

### Java JVM内存划分

   - 线程私有的：
    1. 程序计数器
    2. 虚拟机栈
    3. 本地方法栈
   - 线程共享
    1. 堆
    2. 方法区 （1.8之前，1.8之后 在直接内存中分配一块 元空间）
    3. 直接内存（非运行时数据区的一部分）
- #### 运行时数据区域 
    1. 程序计数器
       - 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。
       另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
       
       - 程序计数器主要有两个作用：
       1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
       2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
       
       - ***注意***：程序计数器是唯一一个不会出现 OutOfMemoryError 
       
    2. java虚拟机栈
    
       - 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。
         
       - Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）
         局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
         
       - Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。
         1. StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
         2. OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
            Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。
         
       - 扩展：那么方法/函数如何调用？          
         1. Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。
         2. Java方法有两种返回方式：
            a. return 语句。
            b. 抛出异常。
         不管哪种返回方式都会导致栈帧被弹出。
         
    3. 本地方法栈
    
       - 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 
       在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
         
       - 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
         
       - 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。
       
    4. 堆
       
       - Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
       - Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。
       进一步划分的目的是更好地回收内存，或者更快地分配内存
       - eden区、s0区、s1区都属于新生代，tentired 区属于老年代。
       大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。
       对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。
       
    ***注意***
         - 1.7 之前HotSpot虚拟机的方法区域（1.8后为元空间）是用永久代实现的。永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
         - 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
    
         - 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
    - 内存分配策略
        1. 对象优先在 Eden 分配
        大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
        
        2. 大对象直接进入老年代
        大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
        经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
        -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
        
        3. 长期存活的对象进入老年代
        为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
        -XX:MaxTenuringThreshold 用来定义年龄的阈值。
        
        4. 动态对象年龄判定
        虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
        
        5. 空间分配担保
        在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
        如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
        
    - 堆中垃圾回收相关：
    
      - 为什么要分代回收对象？
        1. 不同的对象，生命周期是不一样的。因此不同生命周期的对象采用不同的收集方式。
        2. 可以提高垃圾回收的效率。
      - 回收策略：
        1. Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
        2. Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。（在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节）
      - 触发Full GC的条件
        1. 调用 System.gc()
        2. 老年代空间不足
        3. 空间分配担保失败 ：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面堆内存分配第 5 点。
        4. JDK 1.7 及以前的永久代空间不足。
        5. Concurrent Mode Failure ：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
        
    5. 方法区（1.7）
        - 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。
        - 方法区和永久代的关系（方法区也被称为永久代）
            ```$xslt
                方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 
                也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。
             ```
        - 调优参数
            1.8之前:
            ```$xslt
                -XX:PermSize=N //方法区(永久代)初始大小
                -XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
            ```   
            1.8之后：（方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存）
            ```$xslt
                -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
                -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
            ```
        - 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?
            整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。
            你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。
            -XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
            与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
           
    6. 运行时常量池（是方法区的一部分...）
       - 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）
       - 受限于方法区，内存不足也会抛出 OutOfMemoryError 异常。
    7. 直接内存
        - 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。
        - JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。
    
    
- #### 垃圾收集 TODO

    - 判断一个对象是否可以被回收
        1. 引用计数法算法
        2. 可达性分析算法
        3. 方法区的回收
        4. finalize()
    - 引用类型 
        1. 强引用
        2. 软引用
        3. 弱引用
        4. 虚引用
    - 垃圾收集算法
        1. 标记-清楚
        2. 标记-整理
        3. 复制
        4. 分代收集
    - 垃圾收集器
        - HotSpot 7个收集器
             - 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
             - 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

        1. Serial 收集器
        2. ParNew收集器
        3. Parallel Scavenge 收集器
        4. Serial Old 收集器
        5. Parallel Old 收集器
        6. CMS 收集器  
        7. G1 收集器 

- #### 内存分配与回收策略

   - 内存分配策略
       1. 对象优先在 Eden 分配
           大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
           
       2. 大对象直接进入老年代
           大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。    
           经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
           -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
           
       3. 长期存活的对象进入老年代
           为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
           -XX:MaxTenuringThreshold 用来定义年龄的阈值。
           
       4. 动态对象年龄判定
           虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
           
       5. 空间分配担保
           在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
           如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
           
  - 回收策略：
        1. Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
        2. Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。（在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节）
  - 触发Full GC的条件
        1. 调用 System.gc()
        2. 老年代空间不足
        3. 空间分配担保失败 ：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面堆内存分配第 5 点。
        4. JDK 1.7 及以前的永久代空间不足。
        5. Concurrent Mode Failure ：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
        

- #### 类加载机制

    - 类的生命周期
   
    - 包括以下 7 个阶段：
    
        1. 加载（Loading）
        2. 验证（Verification）
        3. 准备（Preparation）
        4. 解析（Resolution）
        5. 初始化（Initialization）
        6. 使用（Using）
        7. 卸载（Unloading）
    - 类加载过程
        包含了加载、验证、准备、解析和初始化这 5 个阶段。
    
        1. 加载
        加载是类加载的一个阶段，注意不要混淆。
    
        加载过程完成以下三件事：
    
        - 通过类的完全限定名称获取定义该类的二进制字节流。
        - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
        - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。
    
        其中二进制字节流可以从以下方式中获取：
    
        - 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
        - 从网络中获取，最典型的应用是 Applet。
        - 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
        - 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。
        
        2. 验证
        确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    
        3. 准备
        类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
    
        实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
    
        初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。
    
        ``` 
        public static int value = 123;
        ```
        如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。
        ```
        public static final int value = 123;
        ```
        4. 解析
        将常量池的符号引用替换为直接引用的过程。
    
        其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
    
        5. 初始化
        初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
    
        <clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：
        ```
        public class Test {
            static {
                i = 0;                // 给变量赋值可以正常编译通过
                System.out.print(i);  // 这句编译器会提示“非法向前引用”
            }
            static int i = 1;
        }
        ```
    
        由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：
    
        ```
        static class Parent {
            public static int A = 1;
            static {
                A = 2;
            }
        }
    
        static class Sub extends Parent {
            public static int B = A;
        }
    
        public static void main(String[] args) {
            System.out.println(Sub.B);  // 2
        }
    
        ```
        接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。
   
        虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。


- 类加载器的分类
    
    a. 从Java虚拟机角度，只有两种不同的加载器
        1. 启动类加载器
        2. 所有其他的类的加载器
    b. 从Java开发人员角度。
        1. 启动类加载器 （Bootstrap ClassLoader）
        2. 扩展类加载器（Extension ClassLoader）
        3. 应用程序类加载器（Application ClassLoader）

- 双亲委派模型
    
    - 类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。
    - 工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。
    - 好处：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。