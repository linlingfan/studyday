### MYSQL

- ### 索引
1. 什么是索引？
    --索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
    好比一本书的目录。加快数据库查询速度。没有索引，默认会遍历全部数据去寻找符合条件的数据。有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。
2. 索引的分类
     1. B+树索引
        - 由搜索引擎的不同可分为：
            1. InnoDB 聚簇索引（聚集索引）按照数据存放的物理位置为顺序的， 能提高多行检索的速度
            2. MYISAM 非聚簇索引（非聚集索引）不是按照数据存放的物理位置为顺序的 MYISAM 对于单行的检索很快
     2. 哈希索引
        - 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
            - 无法用于排序和分组
            - 只支持精确查找，无法用于部分查找和范围查找
        - InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
        
     3. 全文索引
        - MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
        - 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
        - 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
        - InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
          
     4. 空间数据索引
        - MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询 
        -  必须使用 GIS 相关的函数来维护数据。
     
3. 如何创建索引
    1. 添加PRIMARY KEY（主键索引）
```$xslt
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```
   2. 添加UNIQUE(唯一索引)
```$xslt
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```
   3. 添加INDEX(普通索引)
```$xslt
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
 
```
   4. 添加FULLTEXT(全文索引)
```$xslt
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```
   5. 添加多列索引（组合索引）
```$xslt
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```  
4. 索引的优点
    1. 大大减少了服务器需要扫描的数据行数。加快查询速度。
    2. 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。
    3. 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
5. 使用索引的条件
    1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
    2. 对于中到大型的表，索引就非常有效；
    3. 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。
        
- ### 索引优化

- ##### 创建索引的原则：
1. 最左前缀匹配原则
2. =和in可以乱序
3. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*) 表示字段不重复比例，唯一键区分度为1。
4. 索引列不能参与计算，保持列“干净”
5. 尽量的扩展索引，不要新建索引。
6. 定义有外键的数据列一定要建立索引。
7. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
8. 对于定义为text、image和bit的数据类型的列不要建立索引。
9. 对于经常存取的列避免建立索引。

- ##### 索引使用的注意点（具体优化）
1. 索引应建立在那些将用于JOIN,WHERE判断和ORDER BY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。
2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。eg：
```
select id from t where num is null
```
最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.
备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。
不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。

3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。eg：
```$xslt
select id from t where num=1 or Name = 'linfan'
不过可以使用联合查询充分使用索引

select id from t where num = 1
union all
select id from t where Name = 'linfan'

```
5. in 和 not in 也要慎用，否则会导致全表扫描。而且负向查询（not , not in, not like, <>, != ,!>,!< ） 不会使用索引。
   对于连续的数值，能用 between 就不要用 in 了。很多时候用 exists 代替 in 是一个好的选择，当然exists也不跑索引。
7. 模糊查询也将导致全表扫描。
    eg：like %abc% 不使用索引；abc%可以使用索引。
    如果要提高效率，可以考虑全文检索。
    a. like %keyword 索引失效，使用全表扫描。但可以通过翻转函数+like前模糊查询+建立翻转函数索引=走翻转函数索引，不走全表扫描。TODO
    b. like keyword% 索引有效。
    c. like %keyword% 索引失效，也无法使用反向索引。
8. 如果在 where 子句中使用参数，也会导致全表扫描。
    eg: select id from t where num = @num
    不过可以强制使用索引：
    eg: select id from t with(index(索引名)) where num = @num
    应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
    eg: select id from t where num/2 = 100 可改为：select id from t where num = 100*2
9. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
10. 在使用索引字段作为条件时，如果该索引是复合索引（多列索引），那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
11. 应尽可能的避免更新 clustered 索引数据列。
12. MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。

- ### 查询优化
    - Explain 进行分析
    - 优化数据访问
        1. 减少请求数据量
            - 只返回必要的列：最好不要使用 SELECT * 语句。
            - 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
            - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。
        2. 减少服务器端扫描的行数 ：最有效的方式是使用索引来覆盖查询。
                        
    - 重构查询方式
        1. 切分大查询（如：查询条件限制在某个时间段内）
            - 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
        2. 分解大连接查询
            - 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
                1. 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
                2. 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
                3. 减少锁竞争；
                4. ***在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。***
                5. 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。
- ###事务相关
- 事务遵循的特性
    1. 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
    2. 一致性：执行事务前后，数据保持一致；
    3. 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    4. 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

- 事务隔离级别
    1. READ_UNCOMMITTED （未提交读）
    2. READ_COMMITTED （提交读）
    3. REPEATABLE_READ （可重复读）
    4. SERIALIZABLE（串行化）
MySQL 是默认使用REPEATABLE_READ隔离级别；Oracle默认采用READ_COMMITTED隔离级别。
事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVCC（多版本并发控制），通过行的创建时间和行的过期时间来支持并发一致性读和回滚等特性。

- 数据库的脏读,不可重复读，幻读。
    1. 脏读 ：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。
        - 例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。
        - 解决办法：把数据库的事务隔离级别调整到READ_COMMITTED
    2. 不可重复读：不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 
        - 例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 
        - 解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ
    3. 幻读：
        - 例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。 
        - 解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ
    - 不可重复读和幻读的区别
        - 不可重复读重点在于修改（表现在行锁），同样的条件，多次读取结果不一样。
        - 幻读重点在于新增或删除（表现在表锁），同样的条件, 第1次和第2次读出来的记录数不一样
        
- 事务的7种传播行为（spring）


<table>
    <tr>
        <td>ID</td>
        <td>NAME</td>
    </tr>
    <tr>
        <td>1</td>
        <td>A1</td>
    </tr>
    <tr>
        <td>2</td>
        <td>A3</td>
    </tr>
    <tr>
        <td>3</td>
        <td>A3</td>
    </tr>    
</table>

|事务传播行为类型|说明|
|:-|:-|
|PROPAGATION_REQUIRED|如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。|
|PROPAGATION_SUPPORTS|支持当前事务，如果当前没有事务，就以非事务方式执行。|
|PROPAGATION_MANDATORY|使用当前的事务，如果当前没有事务，就抛出异常。|
|PROPAGATION_REQUIRES_NEW|新建事务，如果当前存在事务，把当前事务挂起。|
|PROPAGATION_NOT_SUPPORTED|以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。|
|PROPAGATION_NEVER|以非事务方式执行，如果当前存在事务，则抛出异常。|
|PROPAGATION_NESTED|如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。|

- spring事务注解失效的原因？


- #### 锁机制（MYISAM存储引擎和InnoDB存储引擎的锁）

MySQL为解决并发,数据安全，使用了锁的机制。

  - 按细粒度分类
  
    - 表锁：细粒度最大，对整张表加锁，实现简单，资源消耗比较少，加锁快，不会出现死锁。触发锁冲突的概率最高，并发度最低。
    MyISAM和 InnoDB引擎都支持表级锁。
    
    - 行锁：粒度最小 的一种锁，只针对当前操作的行进行加锁。 
    行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
    InnoDB支持的行级锁算法：
        1. Record Lock:对锁引项加锁，锁定符合条件行。其他事物不能修改和删除加锁项。
        2. Gap Lock:对索引项之间的'间隙'加锁，锁记录范围 (对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。
        其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行(幻读)。
        3. Next-key Lock:锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。

    事务更新大表中的大部分数据直接使用表级锁效率更高；
    事务比较复杂，使用行级索很可能引起死锁导致回滚。
    
    其他相关：
    1. innodb对于行的查询使用next-key lock
    2. Next-locking keying为了解决Phantom Problem幻读问题
    3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
    4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
    5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） 
        A. 将事务隔离级别设置为Read Committed
        B. 将参数innodb_locks_unsafe_for_binlog设置为1

  - 按是否可写分类（表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X））
    - 共享锁（读锁）
        共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。
        若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

    - 排它锁（写锁）
        排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。
        它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。
        在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。
  区别：
        1. 共享锁（S锁）：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。
        获取共享锁的事务只能读数据，不能修改数据。
    
        2. 排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。
        获取排他锁的事务既能读数据，又能修改数据。
    
    - 另外两个表级锁：IS和IX
        意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。
        如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。
        意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。

        InnoDB另外的两个表级锁：
        1. 意向共享锁（IS）： 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。
        
        2. 意向排他锁（IX）： 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。
        
- 死锁和避免死锁
    原因：
    InnoDB的行级锁是基于索引实现的，如果查询语句为命中任何索引，那么InnoDB会使用表级锁. 
    此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。
    不同于MyISAM总是一次性获得所需的全部锁，InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。
    
    避免死锁：
        1. 通过表级锁来减少死锁产生的概率；
        2. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
        3. 同一个事务尽可能做到一次锁定所需要的所有资源。
    发生死锁：发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。


- #### mysql索引的底层数据结构
1. 哈希索引 底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快。其余大部分场景，建议选择BTree索引。
2. BTree索引(主要是B+树) 搜索性能等价于在关键字全集内做一次二分查找
    1. B-树
        特性：
            1.关键字集合分布在整颗树中；
            2.任何一个关键字出现且只出现在一个结点中；
            3.搜索有可能在非叶子结点结束；
            4.其搜索性能等价于在关键字全集内做一次二分查找；
            5.自动层次控制；
            
    2. B+树（B-Tree的一种变种）
        特性（不同于B-Tree的）：
            1.非叶子结点的子树指针与关键字个数相同；
            2.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
            3.为所有叶子结点增加一个链指针；
            4.所有关键字都在叶子结点出现；
            5.内节点不存储data，只存储key
           
       a. MYISAM 非聚集索引 叶节点data域存放数据记录的地址，辅助索引和主索引的区别是辅助索引可以有重复的key
       b. InnoDB 聚集索引 叶节点data域存放完整的数据记录，数据文件本身要按主键聚集（必须要主键），辅助索引都引用主键作为data域（所以使用辅助索引检索，理论要检索两次）。
    - B树(平衡树)相比平衡二叉树
        1.B+-tree的磁盘读写代价更低
        2.B+-tree的查询效率更加稳定
    - 与红黑树的比较
        1. 更少的查找次数
        2. 利用磁盘预读特性
        
    - 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助：
        1. 例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
        2. 再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。
- #### mysql大表优化
    - 限定数据范围
    - 读写分离
    - 垂直分表
    - 水平分区(分片的常见方案)
        1. 客户端代理（Sharding-JDBC）
        2. 中间件代理（mycat）
        
    -  ###### 分库分表
        1. 
        
- #### 分布式事务
参考[https://www.cnblogs.com/jiangyu666/p/8522547.html](https://www.cnblogs.com/jiangyu666/p/8522547.html)

   解决方案：
    1. 基于XA协议的两阶段提交方案。
    2. TCC方案
    3. 基于消息的最终一致性方案
    4. GTS--分布式事务解决方案
    
- #### 存储引擎
    - InnoDB
    - MyISAM
  - 比较：
    - 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
    - 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
    - 外键：InnoDB 支持外键。
    - 备份：InnoDB 支持在线热备份。
    - 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
    - 其它特性：MyISAM 支持压缩表和空间数据索引。
- #### 数据类型
    - 整形
        - TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。
    - 浮点型
        FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。
    - 字符串
        - 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。
    - 时间和日期
        1. DATATIME
            - 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。
        2. TIMESTAMP 
            - 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。
            - 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

- #### mysql集群相关？？

- #### mysql 读写分离的相关配置