
# 使用redis可能遇到的问题

### 缓存雪崩和缓存穿透、缓存击穿解决方案
   - 缓存雪崩
        - 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
        或者某个时刻缓存服务器瞬间宕机（最严重）。
        （缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。）
        - 解决方案
            - 同时失效的话，过期时间加一个随机值。分散缓存过期时间，防止集体失效。
            - 如果是缓存服务器宕机，
                1. 发生前：尽量保证整个redis集群的高可用性。哨兵模式，发现机器宕机尽快补上。选择合适的内存淘汰策略。
                2. 发生中：本地ehcache缓存+hystrix限流&降级。避免数据库崩掉
                3. 发生后：利用redis持久化机制保存数据尽快恢复缓存。
   - 缓存击穿
        -   对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。
        这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。
        - 解决方案：
            1. 使用互斥锁(mutex key) （没必要）
            业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。
            2. "提前"使用互斥锁(mutex key)：
            在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。
            3. "永远不过期"：
                   (1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
                   (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期
            4. 资源保护：
                - 采用netflix的hystrix，可以做资源的隔离保护主线程池。
    
   - 缓存穿透
        - 缓存穿透是指查询一定不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩。
        - 解决办法： 
        有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
        另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。   
    
### 如何解决Redis的并发竞争Key问题

### 如何保证缓存与数据库双写时的数据一致性。