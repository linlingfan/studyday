# RememberMe

***glinlf-2019-03-27***
***

### java基础

---

### 并发
- [x] synchronized相关  done
- [x] ReenTrantLock使用 done
- [ ] ReenTranLock 源码分析 
- [x] java 创建线程池相关  done
- [x] Java Thread状态切换 done
- [x] 原子类相关笔记 done

---

### JVM 

- #### Java JVM内存划分

   - 线程私有的：
    1. 程序计数器
    2. 虚拟机栈
    3. 本地方法栈
   - 线程共享
    1. 堆
    2. 方法区 （1.8之前，1.8之后 在直接内存中分配一块 元空间）
    3. 直接内存（非运行时数据区的一部分）
- #### 运行时数据区域 
    1. 程序计数器
    2. java虚拟机栈 
    3. 本地方法栈 
    4. 堆
    5. 方法区（1.7）
    6. 运行时常量池（是方法区的一部分...）
    7. 直接内存

    
- #### 垃圾收集 TODO

    - 判断一个对象是否可以被回收
        1. 引用计数法算法
        2. 可达性分析算法
        3. 方法区的回收
        4. finalize()
    - 引用类型 
        1. 强引用
        2. 软引用
        3. 弱引用
        4. 虚引用
    - 垃圾收集算法
        1. 标记-清楚
        2. 标记-整理
        3. 复制
        4. 分代收集
    - 垃圾收集器
        - HotSpot 7个收集器
             - 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
             - 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

        1. Serial 收集器
        2. ParNew收集器
        3. Parallel Scavenge 收集器
        4. Serial Old 收集器
        5. Parallel Old 收集器
        6. CMS 收集器  
        7. G1 收集器 

- #### 内存分配与回收策略

  - 内存分配策略
    
  - 回收策略：

  - 触发Full GC的条件


- #### 类加载机制

    - 类的生命周期
   
    - 包括以下 7 个阶段：
        1. 加载（Loading）
        2. 验证（Verification）
        3. 准备（Preparation）
        4. 解析（Resolution）
        5. 初始化（Initialization）
        6. 使用（Using）
        7. 卸载（Unloading）
    - 类加载过程

- 类加载器的分类

- 双亲委派模型
    - 工作过程：
    - 好处：
    
---
    
### java IO

---

### MYSQL

- #### 索引
    - 什么是索引
    - 如何创建索引
    - 创建索引的原则
    - 索引使用的注意点（具体优化）
    - 索引的优点
    - 创建索引的条件
- #### 索引优化
- #### 查询优化
- #### 事务相关

    - 事务遵循的规则
    - 事务隔离级别
    - 事务的传播级别
    
- #### 锁机制（MYISAM存储引擎和InnoDB存储引擎的锁）
    （细粒度分类）
    - 表锁
    - 行锁
    （是否可写分类）
    - 共享锁（读锁）
    - 排它锁（写锁）
    - 死锁和避免死锁
- #### mysql底层的数据结构
    - B树
    - B+树
        MYISAM 非聚集索引 叶节点data域存放数据记录的地址，辅助索引和主索引的区别是辅助索引可以有重复的key
        InnoDB 聚集索引 叶节点data域存放完整的数据记录，数据文件本身要按主键聚集（必须要主键），辅助索引都引用主键作为data域（所以使用辅助索引查寻，理论要查询两次）。
- #### 大表优化
    - 限定数据范围
    - 读写分离
    - 垂直分表
    - 水平分区(分片的常见方案)
        1. 客户端代理（Sharding-JDBC）
        2. 中间件代理（mycat）
- #### 分布式事务
参考[https://www.cnblogs.com/jiangyu666/p/8522547.html](https://www.cnblogs.com/jiangyu666/p/8522547.html)

   解决方案：
    1. 基于XA协议的两阶段提交方案。
    2. TCC方案
    3. 基于消息的最终一致性方案
    4. GTS--分布式事务解决方案
    
- #### 存储引擎
    - InnoDB
    - MyISAM
- #### 数据类型

- #### mysql集群相关？？

---

### Redis

- ### 数据类型 

- ### 数据结构

- ### 使用场景
        
- ### Redis 与 Memcached

- ### Redis过期时间
       
- ### 数据淘汰策略
  
- ### 持久化

    - 快照RDB
    - AOF存储

- ### 事务

- ### 事件 (具体说明)   

   - 单线程两个串行化执行
   
    - 文件事件
    - 时间事件  
    
- ### redis的主从复制
    
- ### Sentinel哨兵模式

- ### redis分片？？？


---

### 网络
    ### 五层协议
        - 在计算机网络中中和OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。
        1. OSI：应用层 表示层 回话层 运输层 网络层 数据链路层 物理层
        2. TCP/IP：应用层 运输层 网际层IP 网络接口层
        3. 五层协议：应用层 运输层 网络层 数据链路层 物理层
        
        - 说明：
            1. 应用层：应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
            2. 运输层：运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。
                - 主要协议：
                    1. 传输控制协议TCP（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。
                    2. 用户数据协议 UDP（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
                - UDP 的主要特点
                    UDP 是无连接的；
                    UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
                    UDP 是面向报文的；
                    UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
                    UDP 支持一对一、一对多、多对一和多对多的交互通信；
                    UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。
                - TCP 的主要特点
                    TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
                    每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
                    TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
                    TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
                    面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。
    
            3. 网络层：在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
            4. 数据链路层：数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。
            5. 在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。
    
    ### TCP 三次握手和四次挥手
       - 三次握手：
            ```
            a. 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
            
            b. 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
            
            c. 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端
            ```     
            1. 为什么要三次握手？
                - 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
            2. 为什么要回传syn
                - 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
            3. 传了 SYN,为啥还要传 ACK
                - 双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。
        
       - 四次挥手（断开TCP连接）
       
       ```
       1. 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
       2. 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。
          和 SYN 一样，一个 FIN 将占用一个序号
       3. 服务器-关闭与客户端的连接，发送一个FIN给客户端
       4. 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1
    
       ```
       - 为什么要四次挥手（双方完全关闭连接）
            - 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
              
       - 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
          
          建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
          而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
    
       [参考链接](https://blog.csdn.net/qzcsu/article/details/72861891)  
    
#### TCP和UDP的区别

#### 浏览器输入url->显示主页的过程

---

### 数据结构

### 算法相关

### 设计模式

### 面试期间相关题mark

-- 有赞

-- 流利说

-- 奇码